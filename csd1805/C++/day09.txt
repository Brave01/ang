回顾：继承
1 继承概念
  基类(父类)--派生-->子类(派生类)
  子类(派生类)--继承-->基类(父类)
2 继承语法
  class Base{};
  class Derivevd:public Base{..};
3 公有继承的特性
1）可以把子类对象当做基类对象来使用
2）向上造型
   子类指针/引用 ---> 基类指针/引用
3）向下造型
	基类指针/引用 ---> 子类指针/引用
4）子类继承基类的成员：公有、保护、私有
5）子类隐藏基类的成员，解决：“类名::”

4 继承方式和访问控制属性

5 子类的构造函数
1）没有指明基类子对象初始化方式，将自动调用基类的无参构造函数来初始化。
2）如果需要用有参的方式初始化基类子对象，则必须使用初始化表.
3）子类对象创建过程
--》分配内存
--》构造基类子对象
--》构造成员子对象
--》执行构造函数代码

===================
今天：
二十一 继承(Inheritance)
...
6 子类的析构函数
1）子类的析构函数，无论自己定义的还是编译器缺省提供的，都会自动调用基类的析构函数，析构基类子对象。
2）子类对象的析构过程
--》执行子类析构函数代码
--》析构成员子对象(按声明逆序)
--》析构基类子对象(按继承表逆序)
--》释放内存
3）基类的析构函数不会调用子类的析构函数，对一个指向子类对象的基类指针使用delete操作符，实际被调用的仅是基类的析构函数，子类的析构函数不会被调用，有内存泄漏的风险。
   解决：虚析构函数(后面讲)
   class A{};
   class B:public A{};
   A* pa = new B;//pa:指向子类对象的基类指针
   delete pa;//有内存泄漏的风险

7 子类的拷贝构造和拷贝赋值
1）拷贝构造
--》如果子类没有定义拷贝构造函数，编译器会为子类提供缺省的拷贝构造函数，该函数会自动调用基类的拷贝构造函数，完成对基类子对象的拷贝。
--》如果自己定义了拷贝构造函数，需要使用初始化表，显式的指明基类子对象也要以拷贝的方式来初始化.
	class Base{};
	class Derived:public Base{
		//Base(that):显式的指明基类子对象也要以拷贝的方式来初始化
		Derived(const Derived& that)
			:Base(that),...{}
	};
2)拷贝赋值
--》如果子类没有定义拷贝赋值操作符函数，那么编译器会为子类提供缺省的拷贝赋值函数，该函数会自动调用基类的拷贝赋值函数，完成基类子对象的复制操作。
--》如果自己定义了拷贝赋值函数，需要显式调用基类的拷贝赋值函数，完成基类子对象的复制操作。
  class Base{};
  class Derived:public Base{
  		Derived& operator=(const Derived& that){
  			//显式调用基类的拷贝赋值函数
  			Base::operator=(that);
  			......
  		}
  };
8 多重继承
1）概念
   一个子类同时继承多个基类，这样继承结构称为多重继承。
  电话	播放器  计算机
  	  \	  |	  /	
  		  智能手机
2)多重继承在向上造型时，编译器会根据基类子对象的内存布局，自动进行偏移计算，保证指针的类型与其所指向的目标对象类型一致.

3）名字冲突问题
  一个子类的多个基类中如果存在相同名字的成员，当通过子类访问它们时，编译器会报歧义错误--名字冲突
  解决名字冲突的一般做法就是显式使用“类名::”，指明所访问的成员属于哪个基类//推荐
  如果产生名字冲突的成员是成员函数并满足不同参数重载条件，也可以通过using声明，让它们在子类中形成重载，通过重载解析来解决//不推荐

9 钻石继承
1)一个子类的多个基类源自共同的基类祖先，这样的继承结构称为钻石继承。
		A
	  / \
	 B   C
	  \ /
	   D
2)公共基类(A)子对象在汇聚子类(D)对象中存在多个实例。在汇聚子类中或者通过汇聚子类对象去访问访问公共基类中的成员，会因为继承路径不同而导致结果不一致。
3）通过虚继承可以让公共基类(A)子对象在汇聚子类(D)对象中实例唯一，并为所有的中间(B、C)类共享，这样即使沿着不用的继承路径，所访问到公共基类中的成员一定是一致的。

10 虚继承语法
1）在继承表中使用virtual关键字修饰
2）位于继承链的最末端子类负责构造公共(虚)基类子对象。
		A(int m_data)
	  / \
	 B   C//:virtual public A
	  \ /
	   D//负责构造公共基类(A)子对象


二十二 多态(Polymorphic)	   
eg：实现图形库，可以用于显示各种图形
			   图形(位置/绘制)
			/ 						\
	矩形(长和宽/绘制) 	圆形(半径/绘制)
	
1 函数重写(虚函数覆盖)、多态的概念
1）如果将基类中的某个成员函数声明为虚函数，那么其子类中与该函数具有相同原型的成员函数就也是虚函数，并且对基类版本形成覆盖，即函数重写.
2）这时，通过指向子类对象的基类指针，或引用子类对象的基类引用，调用虚函数，实际被执行的将是子类中的覆盖版本，而不再是基类中原始版本，这种语法现象称为多态.
	class Base{
	public:
		virtual void func(void){...}
	};
	class Derived:public Base{
	public:
		void func(void){...}
	};
	Derived d;
	Base* pb = &d;//pb:指向子类对象的基类指针
	Base& rb = d;//rb:引用子类对象的基类引用
	pb->func();//执行子类中func
	rb.func();//执行子类中func

练习：复习当天内容
扩展练习V7.0：增加技术主管类
需求：
	1）同时具备技术员属性(研发津贴)和经理属性(绩效奖金)
	2）绩效工资：(技术员绩效+经理绩效)/2
	 员工类(Employee)
	  /			 \
  技术员		    经理
     \          /
       技术主管   