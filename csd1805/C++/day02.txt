回顾：
1 C++语言概述
  C++98
  C++11/C++0x
2 第一个C++程序
1）g++ xx.cpp
2）.cpp
3）头文件 iostream
			 stdio.h ==> cstdio
			 ...
4）输入和输出
	cin、cout
5）std

3 名字空间
1）定义
   namespace 名字空间名{成员...}
2）使用
  	名字空间名::成员;
  	名字空间指令，using namespace std;
  	名字空间声明，using 名字空间名::成员;
3）无名名字空间，“::成员”

4 C++结构体、联合体、枚举

5 字符串 string
1）拷贝：=
2）连接：+ +=
3）比较：== != > >= < <=
4）随机访问：[]
5）成员函数：size()/length()  c_str()

===============================
今天：
六 布尔类型（bool）
1 bool类型是C++中的基本类型，专门表示逻辑值：true(逻辑真)、false(逻辑假)
2 bool在内存占一个字节：1表示true，0表示false
3 bool类型变量可以接受任意类型表达式的结果，表达式结果非0则为true，为0则为false. 
	bool func(){
		return true;
		return false;
	}
	
七 操作符别名 //了解
  && --> and
  || --> or
  !  --> not
  {  --> <%
  }  --> %>
  ......

八 C++的函数
1 函数重载
1)定义
  在相同的作用域，定义同名的函数，但是它们的参数要有所区分，这样的函数之间关系称为函数重载。

2）函数重载匹配
  调用重载关系的函数时，编译器将根据实参和形参匹配程度，自动选择最优的重载版本。
  当前g++编译器匹配的一般规则：
  完全匹配>=常量转换>升级转换>降级转换>省略号

3）函数重载的原理 
  C++编译器是通过对函数进行换名，将参数表的类型信息整合到新的名字中，解决函数重载和名字冲突的矛盾。
  笔试题：C++中extern "C"声明的作用？
  用于声明C++中的函数，要求该函数不做换名，方便C程序调用该函数。
  
2 函数的缺省参数（默认实参）
1）可以为函数的部分或者全部参数指定缺省值，调用该函数时，如果不给传实参，可以用缺省值作为相应的实参值。
  void func(int a,int b,int flag=0){}
2）靠右原则，如果函数的一个参数有缺省值，那么这个参数右侧的所有参数都必须带有缺省值。
	void func(int a = 0,int b){}//error
	void func(int b,int a = 0){}//ok
3）如果函数的定义和声明分开，缺省参数应该写在函数的声明部分，而定义部分不写
	void func(int a = 缺省值);//函数声明
	void func(int a){...};//函数定义

3 函数哑元参数
1）定义：只有类型而没有变量名的形参称为哑元
	void func(int/*哑元*/){...}
2）使用哑元的场景
	--》操作符重载中，区分前后++/--(后面讲)
	--》为了兼容旧代码
	void func(int a,int b){}
	int main(void){
		func(10,20);
		...
		func(30,34);
		...
	}
	------------------------
	void func(int a,int=0/*哑元*/){}//升级版
	int main(void){
		func(10,20);
		...
		func(30,34);
		...
	}
---------------------------
笔试题：inline关键字作用?
4 内联函数(inline)
1)定义
  使用inline关键字修饰的函数，表示这个函数是内联函数，编译器将尝试做内联优化，避免函数的调用开销，提高程序执行效率。

2）说明
--》多次调用的小而简单的函数适合内联
--》调用次数极少或大而复杂的函数不适合内联
--》递归函数不能内联优化

注：内联只是一种建议而不是强制要求，一个函数能否内联优化主要取决于编译器，有些函数不加inline修饰，编译器也会默认处理为内联优化；有些函数即便加了inline的修饰也会被编译器忽略。


//笔试题：C++中new/delete和C中malloc/free区别
九 C++的动态内存分配
1 回顾C中动态内存管理
1）分配：malloc()
2）释放：free()
3）错误处理：返回值

2 C++中使用操作符实现动态内存管理
1）分配：new 、new[]
2）释放：delete、delete[]
3）错误处理：异常机制(后面讲)
eg：
	//C中
	int* pi = (int*)malloc(4);
	*pi = 100;
	...
	free(pi);
	//C++中
	int* pi = new int;
	*pi = 100;
	...
	delete pi;
	-----------------------

十 C++的引用(Reference)
1 定义
1）引用就是某个变量的别名，对引用的操作与对该变量本身完全相同。
2）语法
 	类型 & 引用名 = 变量名;
 	注：引用在定义时必须要初始化，初始化以后绑定的目标不能再修改。
 	注：引用的类型和它绑定的目标变量类型要一致
 	eg:
 	int a = 10;
 	int& b = a;//b就是a的别名
 	b++;
 	cout << a << endl;//11
 	int c = 20；
 	b = c;//赋值操作，不是改变引用的目标
 	cout << a << endl;//20

2 常引用
1）定义引用时加const修饰，即为常引用，不能通过常引用修改引用的目标
	int a = 10;
	const int& b = a;//b就是a的常引用
	//int const& b = a;//和上面等价	
2)普通的引用也可以叫左值引用，只能引用左值;而常引用也可以叫万能引用，既可以引用左值也可以引用右值.
3）关于左值和右值//了解
左值(lvalue)：可以放在赋值操作符左侧，可以被修改
-->非const普通变量都是左值
右值(rvalue)：只能放在赋值操作符右侧，不能被修改
-->常量
-->临时变量
	int a = 100;
	//a(int)-->tmp(double)
	double& r = a;//error 
   int& r = 100;//error

3 引用型函数参数 
1）将引用用于函数参数，这时形参就是实参的别名，可以通过形参直接修改实参变量的值，同时还能避免参数值的传递过程，提高代码执行效率。
2）引用参数可能意外修饰实参的值，如果不希望修改实参变量本身，可以将形参定义为常引用，提高传参效率的同时还可以接收常量型实参。

练习：总结引用和指针区别？(手机百度) 