回顾：
1 构造函数(constructor)
2 对象创建和销毁
1）栈区
	类名 对象(构造实参);
	类名 对象 = 类名(构造实参);
2）堆区
	类名 * 对象指针 = new 类名(构造实参);
3 多文件编程
	xx.h
		class XX{//类的声明
			XX(..);
			返回类型 函数名(..);
		};
	xx.cpp//类的实现
		XX::XX(..){...}
		返回类型 XX::函数名(..){...}{}
4 构造函数可以重载、可以带有缺省参数

5 缺省(无参)构造函数

6 类型转换构造函数（explicit）

7 拷贝构造函数
  类名(const 类名&){...}

8 初始化表
  类名(构造形参):成员变量(初值),...{}
补充初始化表:
  1)如果类中包含"const"和“引用”型的成员变量，必须在初始化表进行初始化。
  2)成员变量的初始化顺序由声明顺序决定，而与初始化表的顺序无关，所以不要使用一个成员变量去初始化另一个成员变量.
--------------------
十五 this指针和常成员函数
1 this指针
1）类中的构造函数和成员函数都隐藏一个该类 类型的指针参数，名为this；在构造函数或成员访问类中的其它成员本质都是通过this指针实现的。
--》对于构造函数，this指向正在创建的对象
--》对于成员函数，this指向该函数的调用对象
2）显式使用this指针的场景
--》区分作用域
--》从成员函数返回调用对象自身//重点掌握
--》从类的内部销毁对象的自身
--》作为函数的实参，实现对象间的交互

2 常成员函数(常函数)
1）在一个成员函数参数表后面加const修饰，表示这个函数时常成员函数。
	返回类型 函数名(形参表) const {函数体} 
2）常函数中的this指针是一个常指针，不能在常函数中修改成员变量的值. 
  注：被mutable关键字修饰的成员变量，可以在常函数中被修改。
3）非 常对象既可以调用常函数也可以调用非常函数，但是常对象只能调用常函数，不能调用非常函数。
	注：常对象也包括常指针或常引用
4）函数名和形参表相同的成员函数，其常版本和非常版本可以构成重载关系，常对象调用常版本，非 常对象调用非常版本。

十六 析构函数(Destructor)
1 语法
  class 类名{
  		~类名(void){
  			负责清理对象生命期内动态分配的资源
  		}
  };
  1）函数名必须是 “~类名”
  2）没有返回类型，也没有参数
  3）不能被重载，一个类只能有一个析构函数
2 当对象被销毁时，该对象的析构函数自动被调用和执行：
1）栈对象离开作用域时，其析构函数被作用域终止右花括号“}”调用；
2）堆对象的析构函数被delete操作符调用。

3 如果一个类没有显式定义析构函数，那么编译器会为该类提供一个缺省的析构函数:
1）对基类类型的成员变量，什么也不做
2）对类 类型成员变量(成员子对象)，会自动调用相应类的析构函数

4 对象的创建和销毁过程
1）对象创建
 --》分配内存
 --》构造成员子对象(按声明顺序)
 --》执行构造函数代码
2）对象销毁
 --》执行析构函数代码
 --》析构成员子对象(按声明逆序)
 --》释放内存
 
十七 拷贝构造和拷贝赋值
1 浅拷贝和深拷贝
1)如果一个类中包含指针形式的成员变量，缺省的拷贝构造函数只是复制指针变量本身，而没有复制该指针所指向的内容，这种拷贝方式称为浅拷贝.
2）浅拷贝将导致不同对象之间的数据共享，如果数据在堆区，析构时还可能发生"double free",导致进程的终止，这时需要定义一个支持复制指针指向内容的拷贝构造函数，即深拷贝。
eg:浅拷贝过程类似
   int* i1 = new int(100);
   int* i2 = i1;//浅拷贝
   delete i2;
   delete i1;//double free
eg:深拷贝过程类似
	int* i1 = new int(100);
	int* i2 = new int(*i1);//深拷贝
	delete i2;
	delete i1;
   
练习：复习当天内容
   
扩展练习V3.0：企业员工管理系统
需求：优化和完善员工类
	1）构造函数改用初始化表初始化成员变量
	2）将员工信息保存到文件中，文件名以工号命名
	