回顾：
1 子类析构函数
2 子类的拷贝构造和拷贝赋值
3 多重继承
1）一个子类同时继承多个基类
2）向上造型，自动偏移计算
3）名字冲突问题，解决“类名::”
4 钻石继承
	A(int m_data)
  / \
 B   C
  \ /
   D	
5 虚继承
	A(int m_data)
  / \
 B   C //virtual public A
  \ /
   D //负责构造公共基类(A)子对象	
===========================================
今天：
二十二 多态(Polymorphic)	   
1 函数重写(虚函数覆盖)、多态的概念
1）如果将基类中的某个成员函数声明为虚函数，那么其子类中与该函数具有相同原型的成员函数就也是虚函数，并且对基类版本形成覆盖，即函数重写.
2）这时，通过指向子类对象的基类指针，或引用子类对象的基类引用，调用虚函数，实际被执行的将是子类中的覆盖版本，而不再是基类中原始版本，这种语法现象称为多态.
	
2 函数重写要求(虚函数覆盖条件)
1）只有类中成员函数才能被声明为虚函数，全局函数、静态成员函数、构造函数都不能为虚函数。
   注：析构函数可以虚(特殊，后面讲)
2）只有在基类中以virtual关键字修饰的成员函数才能作为虚函数被子类覆盖，而与子类中virtual无关。
3)虚函数在子类中的版本和基类中的版本要具有相同的函数签名，即函数名、参数表、常属性一致。
4）如果基类中的虚函数返回基本类型的数据，那么该函数在子类中的版本必须返回相同类型的数据。
5）如果基类中的虚函数返回的是类类型的指针(A*)或引用(A&)，那么允许子类的版本返回其子类类型的指针(B*)或引用(B&)--类型协变。
  class A{}；
  class B:public A{};
  
3 多态的条件
1）多态特性除了要满足虚函数覆盖，还必须通过指针或引用去调用虚函数才能表现出来。
2）调用虚函数的指针也可以是this指针，只要它是一个指向子类对象的基类指针，同样可以表现多态的语法特性。//重点掌握

eg:QT多线程的实现：
	class QThread{//QT官方定义表示多线程类
	protected:
		virtual void run(void){
			//线程的入口函数
		}
	public:
		void start(void){
			this->run();
		}
	};
	class MyThread:public QThread{
	protected:
		void run(void){
			//需要放到线程中执行的代码
		}
	};
	MyThread thread;
	thread.start();

4 纯虚函数、抽象类和纯抽象类
1）纯虚函数
  virtual 返回类型 函数名(形参表)[const] = 0;
2）抽象类
  如果一个类中包含了纯虚函数，那么这个类就是抽象类。
  注：抽象类不能创建对象
3）纯抽象类
  如果一个类所有的成员函数都是纯虚函数，那么这个类就是纯抽象类(有名接口类).	
  
5 多态原理//了解
通过虚函数表和动态绑定来实现：
1）虚函数表会增加内存开销
2）动态绑定会增加时间开销
3）虚函数不能做内联优化
如果没有多态的语法要求，最好不要使用虚函数

6 虚析构函数
1）基类的析构函数不会调用子类的析构函数，对一个指向子类对象的基类指针使用delete操作符，实际被调用的仅是基类的析构函数，子类的析构函数不会被调用，有内存泄漏的风险.
2）可以将基类中析构函数声明为虚函数，那么子类中的析构函数就也是虚函数，并且可以对基类中版本形成有效的覆盖，可以表现多态的语法特性；这时delete一个指向子类对象的基类指针，实际被执行的将是子类的析构函数，而子类析构函数在执行结束以后又会自动调用基类的析构，避免了内存泄漏.

二十三 运行时的类型信息 //了解
1 typeid操作符
  #include <typeinfo>
  typeid(类型/对象)，返回typeinfo对象,里面包含一个name()成员函数，可以返回字符串形式的类型信息。
	注：typeinfo类型支持“==” “!=”操作符，通过它们可以直接进行类型之间的比较，如果类型之间存在多态的继承关系，typeid还可以利用多态语法确定实际的目标对象类型.

2 dynamic_cast动态类型转换操作符
语法形式：
	目标类型变量 = 
		dynamic_cast<目标类型>(源类型变量);
使用场景：
	用于具有多态继承关系父子类指针或引用之间的显式类型转换.
	注：在转换过程中，会检查目标对象和期望转换的对象类型是否一致，如果一致则转换成功，否则转换失败；如果转换的是指针，返回NULL表示失败，如果转换的是引用，抛出异常"bad_cast"表示失败.

扩展练习V8.0：使用多态语法优化继承结构
		 员工类(Employee)
	  /			 \
  技术员		    经理
     \          /
       技术主管  
  
  class 员工类{
  	  void printInfo(){
  	  		printBasic();
  	  		printExtra();
  	  }
  	  void printBasic(){}
  	  virtual void printExtra(){}
  };
  class 技术员{
  	  void printExtra(){}
  };
  员工对象.printInfo()
  技术员对象.printInfo()


扩展练习V9.0：增加公司类，实现对员工增删改查
vi看代码技巧：
   ctags -R * //创建tags文件
   在代码中，把光标放在某个函数名位置：
   ctrl+]，跳转到函数定义位置  
   ctrl+o，跳转回原来位置

