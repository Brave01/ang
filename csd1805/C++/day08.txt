回顾：
二十 操作符重载
1 双目操作符
1）计算类
	a + b ==> a.operator+(b);
	a + b ==> ::operator+(a,b);
2）赋值类
	a += b ==> a.operator+=(b);
	a += b ==> ::operator+=(a,b);
2 单目操作符
1）计算类
	-a ==> a.operator-();
	-a ==> ::operator-(a);
2）自增减
	前++：
		++a ==> a.operator++()
		++a ==> ::operator++(a)
	后++：
		a++ ==> a.operator++(哑元)
		a++ ==> ::operator++(a,哑元)
3 插入和提取操作符
  cout << a; ==> ::operator<<(cout,a)
  cin >> a; ==> ::operator>>(cin,a)

4 下标操作符 []
 A a;
 a[i] ==> a.operator[](i)

5 函数操作符 ()
 A a;
 a(10,20) ==> a.operator()(10,20);

6 new/delete操作符
  //1)A* pa = (A*)A::operator new(sizeof(A))	
  //2)pa->构造函数
  A* pa = new A;
  
  //1)pa->析构函数
  //2)A::operator delete(pa)
  delete pa;

---------------------
今天：
操作符重载的限制：
1）不是所有操作符都能重载，下面几个不能重载：
--》作用域限定操作符  ::
--》直接成员访问操作符 .
--》直接成员指针解引用操作符 .* 
--》条件操作符 ?:
--》字节长度操作符 sizeof
--》类型信息操作符 typeid //后面讲
2）如果一个操作符所有操作数都是基本类型，则该操作符无法重载。
3）操符重载不会改变编译器预定义的优先级
4）操作符重载无法改变操作数的个数
5）无法通过操作符重载发明新的符号
6）只能使用成员形式不能使用全局形式的操作符
	= () [] ->



二十一 继承(Inheritance)
1 继承的概念//了解
  通过一种机制表达类型之间共性和特性的方式，利用已有的数据类型定义新的数据类型，这种机制就是继承。	
  人类：姓名 年龄 吃饭 睡觉
  学生类：姓名 年龄 吃饭 睡觉 学习 学号
  教师类：姓名 年龄 吃放 睡觉 讲课 工资
  ---------------------------------------
  人类：姓名 年龄 吃饭 睡觉
  学生类继承人类：学习 学号  
  教师类继承人类：讲课 工资
  	
  		 人类(基类/父类)
  		/    \
  	学生    教师(派生类/子类)
  	
  	基类--派生-->子类
  	子类--继承-->基类

2 继承的语法
	class 子类:继承方式 基类,...{
		...
	};
	继承方式：
	--》public(公有继承)
	--》protected(保护继承)
	--》private(私有继承)

3 公有继承的特性(public)
1）子类对象会继承基类的属性和行为，通过子类对象可以访问基类中的成员，就如同是基类对象在访问它们一样。
  注：子类对象中包含的基类部分称为“基类子对象”

2）向上造型 //重点掌握
  将子类类型的指针或引用，转换为基类类型的指针或引用。这种操作性缩小的类型转换，在编译器看来是安全，可以直接隐式转换。
  基类
    ↑
  子类
	eg:
	class A{};
	class B:public A{};
	class C:public A{};

	void func(A* pa){...}
	B b;
	func(&b);//向上造型
	C c;
	func(&c);//向上造型

3）向下造型
  将基类类型指针或引用，转换为子类类型的指针或引用。这种操作性放大的类型转换，在编译器看来是危险的，不能隐式转换，但是可以显式转换.
  基类
    ↓
  子类
  
4）子类继承基类的成员
--》在子类中可以直接访问基类中公有或保护成员，就如同它们是子类自己的成员一样.
--》基类中私有成员可以继承过来，但是会受到访问控制属性的限制，无法直接访问；如果需要在子类中访问基类的私有成员，需要通过基类中的公有或保护的接口函数间接访问。

5）子类隐藏基类的成员
-->子类和基类中定义同名的成员函数，因为作用域不同，不能构成重载关系，而是一种隐藏关系，这时通过子类对象将优先访问子类自己的成员，无法直接访问基类中的成员；
--》如果需要通过子类访问基类中被隐藏的成员，可以借助"类名::"显式指明.//推荐
--》通过using声明可以将基类中的成员引入子类的作用域，形成重载，通过重载匹配解决.//不推荐

4 继承方式和访问控制属性
1）访问控制属性：影响访问该类成员的位置
访问控制	  访问控制	内部	子类	外部	友元	
限定符	  属性 		访问	访问	访问	访问
public	  公有成员	Ok		Ok		Ok		Ok
protected  保护成员	Ok		Ok		No		Ok
private	  私有成员	Ok		No		No		Ok
2)继承方式:影响通过子类访问基类中成员的可访问性
基类中的		在公有子		在保护子		在私有子
				类中变成		类中变成		类中变成
公有成员		公有成员		保护成员		私有成员
保护成员		保护成员		保护成员		私有成员
私有成员		私有成员		私有成员		私有成员

5 子类的构造函数
1）如果子类的构造函数没有指明基类部分(基类子对象)的初始化方式，那么编译器将会自动调用基类的无参构造函数来初始化基类子对象.
2）如果希望基类子对象以有参方式的进行初始化，必须要使用初始化表来显式指明.
   class 子类:public 基类{
   	//基类(...):显式指明基类子对象初始化方式
   	子类(...):基类(...){}
   };
3)子类对象构造过程
--》内存分配
--》构造基类子对象(按继承表顺序)
--》构造成员子对象(按声明顺序)
--》执行子类构造函数代码

练习：复习继承相关语法

扩展练习 V6.0：增加技术员和经理类
需求：
	1）技术员类（Technician）
	属性：研发津贴(元/小时)  
   行为：
   	绩效工资计算=研发津贴*工作小时数*进度因数
   	进度因数在计算工资时输入
   2）经理类(Manager)
   属性：绩效奖金(元/月)
   行为：
   	绩效工资计算=绩效奖金*绩效因数(输入)
	  
		员工类(Employee)
	  /			 \
  技术员		    经理

